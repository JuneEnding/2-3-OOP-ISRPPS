using System;
//Наследование: расширение, спецификация, специализация, конструирование, (комбинирование во втором проекте)
//расширение - расширение функцией fb
//расширение самой функции (замещаемой) - изменение её кода.
//общая спецификация - перечень операций одинаковый для обьектов?
//отношения между классами определяется произвольно(на наш выбор)
namespace lab_4
{
    //определение класса
    class A //супер-класс 
    {
        public A()
        {
            this.a = 1;// !!! 1- null
            Console.WriteLine("Конструктор A() сработал");
        }
        ~A()
        {
            Console.WriteLine("Деструктор ~A()");
            //Thread.Sleep(2000);
        }
        //virtual - модификатор для замещаемой функции
        public virtual int fa()
        {
            Console.WriteLine("Функция fa() сработала из класса А");
            return a + 1;
        }
        public int Aa
        {
            set { Console.WriteLine(" set А "); a = value; }
            get { Console.WriteLine(" get А "); return a; }
        }
        //!!!?protected int a { set; get; }    //атрибут везде наследуется (атрибут доступа по умолчанию)
        protected int a = 1;// !!!был типом A 
    }

    class B : A
    {
        public B()
        {
            this.a  = 20;
            this.b  = 10;
            this.b1 = -1;
            Console.WriteLine("Конструктор B() сработал. Атрибут this.a = 20");
        }
        ~B()
        {
            Console.WriteLine("distructor ~Bush()");
            //Thread.Sleep(2000);
        }

        // Замещение + выполнение предыдущего кода в суперклассе
        // Расширение функции
        // Ключевое слово base используется для доступа к членам суперкласса из подкласса
        public override int fa()
        {
            Console.WriteLine("Функция fa() сработала из класса В");
            base.fa(); 
            return a + 10;
        }
        // Расширение класса
        public int fb()
        {
            Console.WriteLine("Сработала функция fb() из класса B");
            return a + b + 10;
        }
        protected   int b   { set; get; } // Атрибут виден наследникам B
        public      int b1  { set; get; }
    }
    //*************************************
    // Ключ. сл. abstract позволяет создавать неполные классы, которые ДОЛЖНЫ БЫТЬ РЕАЛИЗОВАНЫ в производном классе
    // Абстрактные классы могут определять абстрактные методы.
    // Абстрактные методы не имеют РЕАЛИЗАЦИИ, поэтому определение такого метода заканчивается 
    // точкой с запятой вместо обычного блока метода. 
    // Классы, производные от абстрактного класса, должны реализовывать все абстрактные методы. 
    abstract class C : A // Абстрактный класс, нельзя использовать для создания его объекта
    {
        //abstract public int fc();//нет тела
        abstract public int fc_1();
        abstract public int fc_2();
        public void print() { Console.WriteLine("class C print"); }// Будет просто наследоваться
        public int Cc
        {
            set { c = value; }
            get { Console.WriteLine("get С "); return c; }
        }
        protected int c = 1;
    }
    class E : C //!!! ВСЕ абстрактные члены абстр. суперкласса д.б. РЕАЛИЗОВАНЫ!!!
    {
        public E() { this.c = 22; }
        public override int fc_1() //замещаем эту функцию из класса С
        {
            Console.WriteLine("Функция fc1() сработала из класса E");
            return c * 5;
        }
        public override int fc_2() //замещаем эту функцию из класса С
        {
            Console.WriteLine("Функция fc2() сработала из класса E");
            return c / 2;
        }
    }
    class F : C
    {
        public F() { this.c = 1022; }
        public override int fc_1() // Реализуем эту функцию из класса С
        {
            Console.WriteLine("Функция fc1() сработала из класса F");
            return c * 15;

        }
        public override int fc_2() // Реализуем эту функцию из класса С
        {
            Console.WriteLine("Функция fc2() сработала из класса F");
            return c / 2 + 1000;
        }
    }
    // Интерфейс
    interface J     // Можно писать только функции, по опр все паблик, атрибуты нельзы определять
    {               // Интерфейс наследуется только от интерфейса!
        int fj_1(); // Нельзя абстр.! Виртуальные по определению
        int fj_2(); // Только синтаксис
        //int fj()      { return 0; } -- Error
        //public int a  { get; set; } -- Error
    }
    // Спецификация через интерфейс
    class K : J
    {
        public K() { }
        public int fj_1()   { return 10; } // РЕАЛИЗАЦИЯ методов
        public int fj_2()   { return 20; } // Не пишем оверрайт, такой синтаксис
        //public int a      { get; set; }
    }
    // Специализация
    class D : B
    {
        public D() { }
        public override int fa()
        {
            Console.WriteLine("Функция fa() сработала из класса D"); 
            return a + 4;
        }
    }
    class V : B // Конструирование (ставим заглушки на любые функции) Принцип подстановки полностью соблюдается
    {
        public V() { base.fa(); }
        public override int fa() // чтобы убрать функционал, при переопределении убираем текст наслед. замещ. ф-и
        {
            //Console.WriteLine("Не используется");
            return 0;
        }
    }
    // Принцип подстановки сохраняется частично
    //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //  Program
    //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    class Program
    {
        static void Main(string[] args)
        {
    //************************************************************************************
    //--1--
            Console.WriteLine("\nРАСШИРЕНИЕ:\n");
            Console.WriteLine("Создаём обьект A a = new A()");
            A a = new A();
            Console.WriteLine("Вызываем функцию fa() от объекта класса А:");
            Console.WriteLine("a.fa() = {0}", a.fa());
            Console.ReadKey();
            Console.WriteLine();
            Console.WriteLine("Подстановка в объект А объект подкласса В:");
            Console.WriteLine("a = new B()");
            a = new B();
            Console.WriteLine("Вызыв замещенной и расширенной в В функции .fa():");
            Console.WriteLine("a.fa() = {0}", a.fa()); //Замещённая функция (вместо супер-класса становится функцией подкласса)
            Console.WriteLine("Принцип подстановки выполнен полностью");
            Console.ReadKey();
            Console.WriteLine();
    //--2--
            Console.WriteLine("\nОбращение к расширенным членам подкласса В через переопределение типа а");
            Console.WriteLine("(B)a.fb() = {0}", ((B)a).fb()); //Расширение по функциям
            Console.WriteLine("(B)a.b1() = {0}", ((B)a).b1); // Расширение по атрибутам
            Console.WriteLine("Принцип подстановки выполнен частично ");
            Console.WriteLine("из-за необходимости переопределения типа");
            Console.ReadKey();
            Console.WriteLine();

    //************************************************************************************
            Console.WriteLine("\n\nСПЕЦИФИКАЦИЯ:\n");
    //--1--
            Console.WriteLine("СПЕЦИФИКАЦИЯ С ПОМОЩЬЮ АБСТРАКТНОГО КЛАССА");
            Console.WriteLine("Создать объект класса С невозможно, поэтому создадим ссылку на объект:");
            Console.WriteLine("C c = null");
            C c = null; //создаём ссылку на обьект и подставляем под нее обьект который мы пронаследовали 
            Console.WriteLine("Подстановка объекта подкласса Е в суперкласс С");
            Console.WriteLine("c = new E();");
            c = new E();
            Console.WriteLine("Присвоили атибуту суперкласса значение:");
            Console.WriteLine("c.Cc = 455");
            c.Cc = 455;// Присвоили атибуту суперкласса значение
            Console.WriteLine($"Проверим содержимое поля c.Cc = {c.Cc}");
            Console.WriteLine($"Проверка доступности функций:");
            c.print();// Пронаследовалась, вызывается из Абстрактного суперкласса
            c.fc_1(); // Замещение fc() класса С функцией fc() класса Е
            c.fc_2();
            Console.ReadKey();
    //--1.2--
            Console.WriteLine("Подстановка объекта подкласса F в суперкласс С");
            Console.WriteLine("c = new F()");
            c = new F();// Подставляем обьект F
            Console.WriteLine($"Проверка доступности функций:");
            c.print();// Пронаследовалась
            c.fc_1(); // Замещение fc() класса С функцией fc() класса Е
            c.fc_2();
            Console.WriteLine("Принцип подстановки выполнен полностью ");
            Console.ReadKey();
    //--2--
            Console.WriteLine("\nСПЕЦИФИКАЦИЯ С ПОМОЩЬЮ ИНТЕРФЕЙСА");
            Console.WriteLine("Создать объект класса С невозможно, поэтому создадим ссылку на объект:");
            J j = null;
            j = new K(); // Подстановка объекта К
            Console.WriteLine("Проверка доступности функций:");
            Console.WriteLine($" j.fj_1() {j.fj_1()}");
            Console.WriteLine($" j.fj_2() {j.fj_2()}");
            Console.WriteLine("Принцип подстановки выполнен полностью ");
            Console.ReadKey();
    //--3--
            Console.WriteLine("Подстановка объекта Е в суперкласс А ");
            a = new E();
            a.fa(); 
            Console.WriteLine(" Вызыв функции в области видимости объекта Е: a.fa() = {0}", a.fa());
            a = c; // а присвоили значение ссылки, которая хранилась в с т.е. ссылки на объект подкласса, т.е произошла подстановка
            ((C)a).fc_1(); // fc_1() нет в А => относительно А класс F расширен => для доступа к ф-и нужно переопределение типа
            ((E)a).fc_1();
            Console.ReadKey();

    //************************************************************************************
            Console.WriteLine("\nСПЕЦИАЛИЗАЦИЯ:");
            a = new D();
            a.fa();
            Console.WriteLine("Принцип подстановки соблюден"); 
            Console.ReadKey();

    //************************************************************************************
            Console.WriteLine("\nКОНСТРУИРОВАНИЕ:");
            a = new V();
            a.fa();
            Console.WriteLine("Принцип подстановки соблюден"); 


            Console.ReadKey();
        }
    }
}