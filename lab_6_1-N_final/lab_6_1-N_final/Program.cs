using System;

namespace lab_6_1_N_final
{
    class D// 1
    {
        public D() { // Сборка объекта
            this.size = 0;
            this.e = new E[N];// Инициализация массива!!!
            Console.WriteLine("Сработал конструктор D "); 
        }
        ~D() { Console.WriteLine("Сработал ~D"); }

        public int fd() { return 111; }
        public E[] e = null; // Ссылка на начало массива
        // Атрибут доступа к атрибуту е (массиву (ссылке на начало массива))
        public E eA {
            set {
                if (size < N) {
                    this.e[size] = value;
                    size++;
                    Console.WriteLine($"Операция set в массив типа E сработала из D");
                }
                else
                    Console.WriteLine("size >= N ");
            }
            get { 
                Console.WriteLine($"Функция get из массива типа E сработала из D"); 
                return this.e[--size]; // Префиксная запись!!! ..............................разве?
                // Для теста оказалось полезным следующее свойство этой конструкции:
                // Примечательно, что в этом случае, если массив public (хотя не должен быть public!)
                // При get не затираются значения, только уменьшается размер
                // Поэтому так можно обращаться к незатертым старым элементам в массиве 
                // И после операции get
            }
        }
        private int size = 0; // Инициализация первичного числа заполненных ячеек массива
        private int N = 5;    // Инициализация максимального размера массива
    }
    class E // N
    {
        public E() { Console.WriteLine("Сработал конструктор по умолчанию E"); }
        public E(D d) { this.d = d; Console.WriteLine("Сработал конструктор E с пар. d"); }
        ~E() { Console.WriteLine("Сработал ~E"); }
        public int fe() { return 222; }
        public D d { set; get; } // Cсылка на объект класса D
    }          
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Ассоциакия один ко многим:");
            //E e = new E();
            D d = new D(); // Констр по умолч нет....
            E e1 = new E();
            E e2 = new E();
            E e3 = new E();
            E e4 = new E();
            E e5 = new E();
            // Инициализируем массив ссылок е класска d c помощью атрибута доступа e (set)
            d.eA = e1; d.eA = e2; d.eA = e3; d.eA = e4; //d.eA = e5; // В комментарии для отладки
            //Из объекта d с помощью атр. доступа get позвращаем ссылку на е и выполняем ф-ю класса е
            Console.WriteLine($"d.eA.fe(); = {d.eA.fe()}");
            // Инициализируем атрибут - ссылку на d в объектах e
            e1.d = d; e2.d = d; e3.d = d; e4.d = d; e5.d = d;

            // Доступ к функции fd через ссылку d от объектов типа Е
            Console.WriteLine($"e1.d.fd() = {e1.d.fd()}");
            Console.WriteLine($"e5.d.fd() = {e5.d.fd()}");

            // Доступ к функции fe через ссылку e от объектов типа D (без атр доступа, для отладки!!!!!)
            // !!! На практике доступа к ним не должно быть, 
            // Но я решила проверить наличие ссылок на объекты Е в массиве-атрибуте класса D
            // Поэтому поставила модификатор доступа public массиву типа E
            Console.WriteLine($"d.e[0].fe() = {d.e[0].fe()}");
            Console.WriteLine($"d.e[2].fe() = {d.e[2].fe()}");
            // Проверка доступа к элементым массива, ранее мы не определили поле d.eA, т. е. e[4], в этом элементе
            // Не должно быть ссылки на экземпляр объекта
            // Console.WriteLine($"e.d.fd() = {d.e[4].fe()}"); // Ссылка на объект не установлена на ЭКЗЕМПЛЯР объекта, действительно
            // Console.WriteLine($"e.d.fd() = {d.e[3].fe()}"); // Ссылка на объект е после функции get не затерлась, действительно

            Console.ReadKey();

        }
    }
}

